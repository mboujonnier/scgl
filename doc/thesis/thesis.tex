\documentclass[a4paper,12pt,polish,oneside]{thesis}
\usepackage{listings}
\usepackage{multicol}
\usepackage{multirow}

\lstdefinestyle{line}{
	language=C,
	basicstyle=\ttfamily,
}

\lstdefinestyle{code}{
	language=C,
	basicstyle=\ttfamily\scriptsize,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	captionpos=t,
	breaklines=true,
	frame=single,
	breakatwhitespace=false,
}

\lstdefinestyle{coden}{
	language=C,
	basicstyle=\ttfamily\scriptsize,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	captionpos=t,
	breaklines=true,
	frame=single,
	breakatwhitespace=false,
}

\newcommand\code[1]{\lstinline[style=line]{#1}}
\renewcommand{\lstlistlistingname}{Spis listingów}

\autor{Patryk Kwiatkowski}
\tytul{Podstawowa biblioteka grafów~w~C}
\tytulAng{Simple C~graph library}
\promotor{dr inż. Ireneusz Szcześniak}
\rok{2012}
\kierunek{Informatyka}
\specjalnosc{Sieciowe Technologie Informatyczne}
\numerAlbumu{101510}
\studia{stacjonarne}
\stopien{II}

\begin{document}

\stronaTytulowa

\tableofcontents

\chapter*{Cel pracy}
\addcontentsline{toc}{chapter}{Cel pracy}

Celem pracy jest stworzenie oprogramowania komputerowego umożliwiającego tworzenie aplikacji, wykorzystujących w~swym działaniu elementy matematycznej teorii grafów.
Oprogramowanie to, dalej zwane \emph{biblioteką} powinno dostarczyć interfejs programistyczny (API), pozwalający na tworzenie oraz działanie na podstawowych elementach grafów.
Biblioteka ta powinna również implementować jeden z~wybranych algorytmów teorii grafów.

Oprogramowanie to powinna poprawnie działać na systemach operacyjnych rodziny Linux, przy zachowaniu jak najmniejszych wymagań na ich zasoby pamięciowe oraz obliczeniowe.
Powinna również dostarczać mechanizm testów jednostkowych --- bazujących na dowolnej platformie testowej --- pozwalających na dalszy rozwój oprogramowania.

Spełniając powyższe wymagania, biblioteka ta powinna zostać stworzona przy użyciu języka C. Zachowując przy tym prostotę oraz przejrzystość kodu źródłowego.
Kod ten powinien być również dobrze udokumentowany, zarówno za pomocą poniższej pracy jak i~wygenerowanej automatycznie dokumentacji.

\chapter*{Wstęp}
\addcontentsline{toc}{chapter}{Wstęp}

Systemy nawigacji GPS, sieć Internet, gry komputerowe, translatory języków obcych, biologia, chemia, socjologia --- to wszystko, i~wiele innych dziedzin życia, łączy jeden wspólny element, teoria grafów.
Kiedy rozwój informatyki pozwolił na reprezentowanie grafów za pomocą komputera, okazało się, że algorytmy na nich oparte znajdują wiele praktycznych zastosowań.
Grafy są jednymi z~najbardziej wszechobecnych modeli zarówno świata naturalnego jak i~stworzonego przez człowieka.

Oprogramowanie oparte na analizie grafów znalazło zastosowanie w~wyznaczaniu trasy pomiędzy punktami na mapie, czy najszybszej drogi ewakuacji z~kompleksu budynków.
Przedstawienie sieci komputerowych w~postaci grafów pozwoliło na stworzenie programów usprawniających przepływ pakietów w~Internecie.
W fizyce materii skondensowanej, trójwymiarowa struktura skomplikowanych symulacji struktur atomowych może zostać zbadana poprzez gromadzenie danych statystycznych dotyczących właściwości związanych z~topologią atomów przedstawioną właśnie przy użyciu grafów.
Ta dziedzina matematyki jest równie przydatna w~biologii, gdzie wierzchołek może reprezentować regiony, w~których niektóre gatunki istnieją, a~krawędzie ścieżki migracji. Informacja ta jest ważna, gdyż patrząc na powstałe wzorce, można zbadać wpływ rozprzestrzeniających się chorób, pasożytów czy zmiany ruchów na inne zwierzęta.

Dzięki możliwością jakie dają dzisiejsze komputery w~przetwarzaniu informacji, powstało wiele bibliotek obsługujących obliczenia oparte o~teorię grafów.
Rozwiązania te pojawiają się w~niemal każdym języku programowania, od \emph{C++}, przez \emph{D}, aż do \emph{Pythona} czy \emph{Matlaba}.
Tematyka teorii grafów, ze względu na szeroką gamę zastosowań oraz dużą przydatność --- zwłaszcza przy analizie, projektowaniu oraz udoskonalaniu sieci komputerowych --- została wybrana przez autora, jako temat przewodni niniejszej pracy naukowej.
Mimo istnienia dużej ilości bibliotek komputerowych implementujących zagadnienia tej tematyki, niewiele z~nich cechuje się prostotą oraz przejrzystością kodu źródłowego.
Zaś wiele z~nich zazwyczaj zużywa wiele zasobów pamięciowych, oraz działa względnie powolnie.
Potrzeba ograniczenia zużywanych zasobów, oraz stworzenia projektu prostego i~czytelnego, była główną motywacją autora do podjęcia się stworzenia ,,\emph{Prostej biblioteki grafów w~C}''.

Rozdział pierwszy niniejszej pracy zawiera wiedzę teoretyczną posiadaną, lub zebraną, przez autora pracy na potrzeby realizacji wcześniej przedstawionych celów.
W~rozdziale tym wymienia się i~opisuje pojęcia związane z~szeroko pojętą teorią grafów, kładąc szczególny nacisk na wykorzystywane później jej elementy.

Drugi rozdział pracy zawiera szczegółowy opis zaprojektowanej biblioteki.
Wyjaśnia powody wyboru konkretnych technologii do realizacji obranych celów.
W~rozdziale tym przedstawiona została budowa poszczególnych modułów, sposób przechowywania informacji oraz metody usprawniające pracę przy dalszym rozwoju biblioteki.
Zawiera on też kilka przykładów wykorzystania interfejsu użytkownika.

Rozdział trzeci pracy przedstawia porównanie stworzonego na cele pracy projektu, z~istniejącymi już rozwiązaniami.
Porównania te zostały przeprowadzone pod kątem ilości zużywanej pamięci, oraz czasu jaki jest potrzebny na wykonanie podstawowych funkcji tego typu biblioteki.

Dodatkowo na końcu pracy, jako załącznik, zamieszczona została automatycznie wygenerowana, anglojęzyczna dokumentacja niniejszej biblioteki.

\chapter{Wybrane zagadnienia teorii grafów}
graf, krawędź, węzeł, rodzaje grafów (nieskierowany skierowany), zastosowania grafów, modelowanie sieci 
\section{Algorytm Dijkstry}
pseudokod, po co, złożoność, porównanie do innych (złożoność)


%\chapter{Biblioteki w systemach Unix / Linux}
%co to, po co 
%\section{Statyczne}
%zalety / wady jak tworzyc
%\section{Współdzielone}
%zalety /wady umiejscowienie


\chapter{Realizacja biblioteki}
Do zrealizowania postawionych w~pracy celów zaprojektowano oraz zaimplementowano bibliotekę nazwaną \emph{Simple C~Graph Library}, dalej określaną akronimowi \emph{SCGL}.
Projekt ten stworzony został w~oparciu o~język C~oraz jego bibliotekę standardową (w systemach Unix/Linux: \emph{GNU libc - glibc}).
Postanowiono również, że biblioteka będzie implementować algorytm Dijkstry --- najkrótszych ścieżek --- ze względu na jego popularność oraz istotność dla modelowania sieci komputerowych.

Wyboru tego dokonano przede wszystkim ze względu na możliwość redukcji wszelkich narzutów wynikających z~cech charakterystycznych dla języków obiektowych (dziedziczenie, polimorfizm, szablony).
Dodatkowym atutem było bardzo dobre wsparcie kompilatorów oraz szeroki wybór dostępnych narzędzi dla języka C.

Projekty takie jak ten przedstawiony w niniejszej pracy często charakteryzują się dynamicznym rozwojem, zwłaszcza w początkowych fazach tworzenia.
W~celu zapewnienia poprawności zaimplementowanych już funkcjonalności, zdecydowano się skorzystać z~mechanizmu testów jednostkowych oraz platformy \emph{DejaGNU}.

Dodatkowo biblioteka wykorzystuje program \emph{make} oraz pliki reguł \emph{Makefile} do automatyzacji procesu kompilacji.

Podczas projektowania każdego z~modułów biblioteki wykorzystano wiedzę zawartą w publikacjach TODO, TODO oraz stosowano się do reguły KISS (ang. \emph{Keep It Simple, Stupid}), która traktuje o tym, że im coś jest prostsze (jako koncept, oraz jako wykonanie) tym lepiej TODO (kiss).
\label{kiss}
\section{Budowa projektu}
\subsection{Diagram klas}
powiązanie klas i opisać każdą z osobna
\subsection{Struktura plików}
Całość projektu, kod źródłowy biblioteki, platformę testów jednostkowych, oraz dodatkowe elementy wykorzystane podczas pisania niniejszej pracy, przechowywane są przy wykorzystaniu repozytorium \emph{git}\footnote{Git --- rozproszony system kontroli wersji, stworzony przez Linusa Torvaldsa jako narzędzie wspomagające rozwój jądra Linux.}.
Owe repozytorium umieszczone jest na serwerach darmowego serwisu \emph{https://github.com/}, a~jego lokalna kopia na płycie CD dołączonej do pracy (więcej na str. \pageref{chap:cd}).

Zgodnie z~dobrą praktyką programistyczną, oraz w~celu uporządkowania plików źródłowych, zastosowana została standardowa hierarchia plików.
W~katalogu głównym \emph{scgl/} (w~pliku \code{LICENSE}) znaleźć można treść licencji (dwu-klauzulowa licencja BSD) biblioteki, krótki opis projektu (\code{README}) oraz plik ułatwiający m. in. kompilację kodu \code{Makefile} (więcej na str. \pageref{chap:make}).
Kod źródłowy poszczególnych modułów SCGL znajduje się w~podkatalogu \code{src}, a~pliki definicji struktur oraz funkcje użytkownika (\emph{API}), w~podkatalogu \code{include}.

Dodatkowo wewnątrz katalogu \emph{scgl/} znajdziemy pliki stworzone przez generator dokumentacji ---  \emph{doxygen} (\code{doc/latex}).
Są to pliki tworzące dokumentację interfejsu użytkownika, przy wykorzystaniu komentarzy zawartych w~kodzie źródłowym SCGL.

Katalog \code{unit\_tests/scgl.test} zawiera definicje testów \emph{DejaGNU} oraz sam moduł wykorzystywany do testowania biblioteki.

W~folderze \code{perf\_tests} znajdują się kody źródłowe (oraz plik Makefile) testów wydajności wykorzystanych do porównania, opisanego w~rodziale \ref{chap:tests}.

\section{Szczegóły implementacji}
ze postanowiono nie ukrywać struktur, można, ale nie trzeba
że odbiega od UML bo C nie ma prv public
że wykorzystuje listy (czyt. )
że implementuje dijkstre

\subsection{Linux Kernel List}
%TODO napisać o atrybutach edge?
Zjawiska modelowane przy wykorzystaniu teorii grafów, charakteryzują się zazwyczaj dużą dynamiką zmian w~czasie.
Przykładowo, w~miarę rozwoju firmy na rynku, rozwija się jej infrastruktura wewnętrzna --- struktura sieci komputerowej jest rozbudowywana o~nowe lokacje, co za tym idzie urządzenia trasujące (przedstawiane jako węzły grafu).
Fakt ciągłych zmian w~budowie grafów, narzuca niejako implementującej go bibliotece, wymaganie obsługi tego typu zdarzeń.
Musi być ona w~stanie dynamicznie zmienić rozmiary struktur, tak aby w~każdej chwili dodać (lub usunąć) wybrane elementy.

W~językach takich jak \emph{C++} najczęściej do tego celu wykorzystywane są tzw. wektory, czyli tablice o~dynamicznych rozmiarach.
Korzystając z~nich nie musimy podawać, podczas tworzenia, ilości elementów jakie będą w~nich przechowywane.
A~w~trakcie dodawania/usuwania elementów, rozmiar tablicy dostosowuje się automatycznie.

Wybrany do realizacji celów pracy język C, nie posiada wbudowanej obsługi podobnych mechanizmów wbudowanych w~standardową bibliotekę.
Istnieje co prawda możliwość rozszerzania rozmiaru tablicy (przy pomocy funkcji \code{realloc}), jednakże jest to mało wydajny mechanizm, zwłaszcza przy dużej ilości operacji dodawania/usuwania.
Innym rozwiązaniem byłyby biblioteki zewnętrze, przeznaczone dla języka C, dodające brakującą funkcjonalność.
Użycie ich może jednak wiązać się z~dodatkowymi dużymi narzutami na rozmiar biblioteki, zużywaną pamięć lub szybkość działania.
Aby zniwelować wpływ (negatywny) kodu ,,trzeciego'' na SCGL, postanowiono wykorzystać mechanizm list dowiązanych do przechowywania informacji na temat wszystkich krawędzi (ich atrybutów) oraz węzłów w~grafie.
Zasada działania jak i~implementacja tego typu list jest niezwykle prosta, a~jednocześnie nie wpływa znacząco na ilość zużywanej pamięci.

Wg klasycznego podejścia do problemu, lista jest to obiekt (struktura/klasa) zawierająca dane właściwie, oraz wskaźnik na kolejny obiekt tego samego typu.
\begin{lstlisting}[style=code,caption=Idea listy powiązanej w~C]
struct list {
	struct list *prev
	struct list *next;
	void *data;
};
\end{lstlisting}
Posiadając wskaźnik, wskazujący na pierwszy element listy (\code{head}), możemy otrzymać dostęp do kolejnych danych przechowywanych wewnątrz listy poprzez wyłuskiwanie kolejnych wskaźników (\code{next}/\code{prev}).

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{linkedlist.eps}
		\caption{Kolejne elementy listy powiązanej}
	\end{center}
\end{figure}

%TODO czym się charakteryzuje jakie czasy i O(n)
%TODO moze napisać o atrybutach krawędzi że dynamiczne, moze w Linux Kernel List? :D

W~niniejszej pracy postanowiono jednak skorzystać z~mechanizmu nazwanego \emph{Linux Kernel List}.
Jest to implementacja listy dowiązanej, (dwukierunkowej; cyrkulacyjnej), wykorzystywana w~jądrze (ang. \emph{kernel}) systemów operacyjnych \emph{Linux}
Jest to jeden plik nagłówkowy (\code{*.h}) języka C.
Zawiera on definicję struktury \code{list\_head} oraz definicje i~deklaracje funkcji oraz makr preprocesora, obsługujących tą strukturę.
Linux Kernel Lists są wyjątkowe, z~powodu trochę innego podejścia do tematu.
Struktura \code{list\_head} zawiera jedynie informację (wskaźniki) na następny oraz poprzedni element listy.
Brak jest tu standardowego pola \code{data}, które przechowywałoby informacje użytkownika (tak jak jest to realizowane w~standardowej implementacji listy).
W~rozwiązaniu Linuksowym, realizacja listy daje złudzenie, że lista zawarta jest w~obiekcie który łączy (który powinien być wewnątrz niej).
Na przykład, jeśli chce się stworzyć listę powiązaną struktur \code{my\_struct}, należy zrobić to w~następujący sposób:
\begin{lstlisting}[style=code,caption=Przykład tworzenia listy powiązanej za pomocą Kernel Lined List]
struct my_struct{
	struct list_head list; /* struktura kernel list */
	int my_data;
	void *my_void;
};
\end{lstlisting}
Gdzie struktura \code{list\_head} zbudowana jest następująco:
\begin{lstlisting}[style=code]
struct list_head{
	struct list_head *prev;
	struct list_head *next;
};
\end{lstlisting}
Dołączamy strukturę listy do własnego obiektu, zamiast, obiekt do struktury listy.
Dodając kolejne elementy listy, łączymy ze sobą tak naprawdę kolejne struktury \code{list\_head}.

Najważniejsze przy obcowaniu z~listami jądra Linuksa to:
\begin{itemize}
	\item Lista jest wewnątrz obiektów, które chcemy razem połączyć.
	\item Można umieścić strukturę \code{list\_head} w~każdym miejscu własnej struktury.
	\item Zmienna typu \code{list\_head} może mieć dowolną nazwę.
	\item Rozwiązanie to nie ogranicza nas do jednej listy, na cały kod źródłowy.
\end{itemize}
Ponieważ jest to mechanizm zapożyczony z jądra systemu Linux, istnieje pewność iż jest dobrze przetestowane, przenośne, szybkie oraz zajmuje niewiele pamięci.
Warto również wspomnieć, iż ten sam plik nagłówkowy, dostarcza podstaw do implementacji tablic asocjacyjnych (ang. \emph{hash list}).

Potrzebne były pewne modyfikacje, aby plik nagłówkowy \code{list.h} dostosować do zwykłego kodu, przestrzeni użytkownika (ang. \emph{userspace}):
\begin{enumerate}
	\item Została zmieniona definicja pliku nagłówkowego \code{list.h}
	\item Zostały usunięte załączone pliki nagłówkowe
	\item Zostały dodane struktury znajdujące się w~pliku \code{types.h}
	\item Wywołanie makra \code{offsetof} z~pliku \code{stddef.h}, zostało zamienione na jego treść
	\item Zmienne \code{LIST\_POISON1} oraz \code{LIST\_POISON2} zostały zastąpione przez wskaźnik na NULL --- sens pozostaje taki sam
\end{enumerate}
Dodatkowo na potrzeby biblioteki SCGL dopisana została funkcja \code{list\_count} obliczająca ilość elementów wewnątrz listy:
\begin{lstlisting}[style=code,caption=Ciało funkcji {list\_count}]
static inline unsigned int
list_count(const struct list_head *head) {
	unsigned int i = 0;
	struct list_head *j;
	list_for_each(j, head) {
		++i;
	}
	return i;
}
\end{lstlisting}

Jak już zostało wspomniane, łącząc kolejne elementy, łączymy ze sobą struktury \code{list\_head}.
Wymusza to na programiście, zmianę toku myślenia.
Chcąc przechowywać listę krawędzi wewnątrz struktury grafu, musimy w~obu tych obiektach dołączyć strukturę \code{list\_head}.
Im więcej list krawędzi chce się stworzyć, tym więcej zmiennych typu \code{list\_head} należy wpisać w~budowę obiektu.
I~tak biblioteka SCGL posiadając pięć list:
\begin{enumerate}
	\item krawędzi w grafie,
	\item węzłów w grafie,
	\item krawędzi wchodzących do węzła,
	\item krawędzi wychodzących z węzła,
	\item atrybutów krawędzi.
\end{enumerate}
Musi mieć wpisane w~struktury dziesięć, zmiennych typu \code{list\_head}.

\begin{lstlisting}[style=code,caption=Zastosowanie Linux Kernel List na przykładzie struktur biblioteki SCGL]
/** attribute object */
struct scgl_attr {
	list_head_t list;
};

/** edge object */
struct scgl_edge {
	list_head_t from_list;
	list_head_t to_list;
	list_head_t owner_list;
	list_head_t attributes;
};

/** vertex object */
struct scgl_vertex {
	list_head_t in;
	list_head_t out;
	list_head_t owner_list;
};

/** graph object */
struct scgl_graph {
	list_head_t vertexes;
	list_head_t edges;
};
\end{lstlisting}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{listconnection.eps}
		\caption{Diagram połączeń pomiędzy listami dowiązanymi biblioteki SCGL}
	\end{center}
\end{figure}

Zastosowanie list powiązanych, zapożyczonych z~jądra Linuksa, pozwoliło na oszczędzenie pamięci oraz szybkości działania.
Przyśpieszyło i ułatwiło to również sam proces tworzenia biblioteki SCGL.
Nie warto tworzyć kolejnych rozwiązań od nowa, jeśli istniejące są dobrze zaimplementowane.

\subsection{Statycznie kompilowany typ zmiennej}
Sporym oraz ciekawym wyzwaniem projektowym okazał się niepozorny atrybut kosztu (wagi) krawędzi, a~właściwie typ zmiennej przechowującej tą wartość.
Jak już zostało wcześniej wspomniane, element ten wykorzystywany jest przy wyborze ścieżki pomiędzy zadanymi węzłami.
Wymaganiem postawionym przed biblioteką SCGL była elastyczność typu zmiennej określającej koszt krawędzi.
Biblioteka powinna pozwalać użytkownikowi na wybór typu owego parametru według własnych preferencji, bez ingerencji w~sam kod projektu.

Problem ten dotyka tematyki paradygmatu programowania uogólnionego (generycznego, ang, \emph{generic programming}).
Pozwala on na pisanie kodu programu bez wcześniejszej znajomości typów danych, na których kod ten będzie pracował.
W~językach Java, C\#, Haskell służą do tego typy generyczne (typ ten pojawia się również w C++ dzięki zastosowaniu biblioteki \emph{boost::any}).
Zaś w~językach takich jak C++ czy D, funkcjonalność tą można zrealizować poprzez zastosowanie mechanizmu szablonów (ang. \emph{template}).
Podczas kompilacji następuje tak zwana konkretyzacja szablonu (ang. \emph{template instantiation}), podczas której kompilator na podstawie typów danych przekazanych wzorcowi generuje kod właściwy do obsługi danego typu.
Dla każdego użycia szablonu z~innym typem, generowana jest kopia odpowiednich fragmentów kodu.

Wybrany dla biblioteki SCGL język C~nie posiada żadnego z~wyżej wymienionych mechanizmów.
Aby spełnić postawione wymagania rozważano kilka możliwości projektowych, jedną z~nich było zastosowanie unii z~kilkoma podstawowymi typami zmiennych skalarnych, oraz dodatkowego pola określającego wybrany typ.
Wykorzystanie unii do tego celu, miałoby ograniczyć ilość zużytej pamięci, do największej zmiennej wewnątrz unii.
\begin{lstlisting}[style=code,caption=Koszt krawędzi jako unia]
enum cost_type {INT, DOUBLE, FLOAT};

struct scgl_edge {
   union cost {
       int i;
       double d;
       float f;
   };
   cost_type type;
};
\end{lstlisting}
Rozwiązanie to niestety wymagałoby każdorazowego sprawdzania wartości zmiennej \code{type} przed użyciem zmiennej \code{cost} (ponieważ należy wskazać którą zmienną wybieramy z~unii).
Instrukcja warunkowa \code{switch} (rozrastająca się w~miarę dodawania nowych typów do unii) negatywnie wpłynęłaby na wydajność funkcji wykorzystujących atrybut kosztu.
Alternatywnym rozwiązaniem byłoby stworzenie, dla każdego typu, funkcji posługujących się odpowiednią zmienną z~unii np:
\begin{lstlisting}[style=coden]
void scgl_dijsktra(/*...*/)
void scgl_dijkstra_int(/*...*/)
void scgl_dijkstra_float(/*...*/)
void scgl_dijkstra_double(/*...*/)
\end{lstlisting}
Zmniejszyłoby to narzut wynikający z~każdorazowego sprawdzania typu zmiennej kosztu (sprawdzanie odbywałoby się przez warper \code{scgl\_dijkstra()}, który wywoływałby odpowiednią funkcję).
Niestety rozwiązanie to jednocześnie zwiększyłoby znacznie ilość rozmiar biblioteki, dodatkowo narażając kod na błędy rodzaju copy-paste (wynikające z powielania ciała funkcji poprzez kopiowanie i~wklejanie).
Dodatkową wadą tego rozwiązania, jest fakt, iż unia zajmuje tyle miejsca co jej największa składowa. Gdyby w~jej wnętrzu znalazła się zmienna typu \code{long double} to mimo iż programista wykorzystywał by \code{cost} jako zmienną short, to pole zajmowałoby tyle bajtów ile \code{long double} na danej architekturze.

Z~powodu wyżej wymienionych cech, zdecydowano się zastosować zupełnie inne rozwiązanie.
Postanowiono stworzyć wewnątrz pliku nagłówkowego \emph{scgl\_edge.h} alternatywną nazwę (\code{typedef}), a~następnie zdefiniować wewnątrz struktury krawędzi pole będące realizacją jej kosztu w~następujący sposób:
\begin{lstlisting}[style=code,caption=Koszt krawędzi w~bibliotece SCGL]
typedef cost_type cost_type_t;

struct scgl_edge {
	cost_type_t cost;
};
\end{lstlisting}
Kod ten oczywiście nie ma prawa zadziałać, gdyż symbol \code{cost\_type} dalej pozostaje niezdefiniowany.
Odpowiedzialność za tę czynność przeniesiono do etapu kompilacji biblioteki, a~właściwie etapu translacji.
Kompilator \emph{gcc} poprzez opcję \code{-D} umożliwia definiowanie nazw, traktując je tak jakby w~kodzie pojawił się odpowiednio skonstruowany blok \code{\#define}.
\begin{lstlisting}[style=coden]
gcc -Dname=definition
gcc -Dcost_type=double
gcc -Dcost_type=int
\end{lstlisting}
Kompilując kod z~tym parametrem słowo \code{cost\_type} jest podmieniane na wybrany przez użytkownika typ, co za tym idzie zmienna \code{cost} przybiera wybrany typ.
Statyczny typ zmiennej, dobierany podczas procesu kompilacji nie powoduje dodatkowego narzutu przed jej użyciem (jak to miało miejsce w~przypadku unii), czy na rozmiar biblioteki (szablony języka C++).
Wadą jest tu jednak potrzeba rekompilacji całej biblioteki (wszystkich modułów, które korzystają ze zmiennej), za każdym razem gdy użytkownik zechce zmienić jej typ.
Jest to jednak niedogodność, którą można zaakceptować, zważywszy na możliwości, którą oferuje owe rozwiązanie.

Dodatkowym elementem wynikającym z~wybranego rozwiązania, jest potrzeba dbania o~zależności.
Wybór typu zmiennej powinien dostarczać dodatkowych informacji takich jak minimalna/maksymalna wartość zmiennej, oraz format zmiennej rozumiany przez funkcję \code{printf}.
Aby ułatwić proces budowania biblioteki, oraz zmniejszyć ewentualną możliwość popełnienia błędu przez użytkownika, postanowiono, że doborem wcześniej wymienionych wartości zajmie się plik \emph{Makefile}.
Wewnątrz tego pliku zdefiniowane są reguły budowania całej biblioteki (oraz dodatkowych elementów).
Makefile definiuje zmienną \code{COST\_TYPE}, która może przyjąć wartości odpowiadające określonemu typowi zmiennej \code{cost}.
Na podstawie wyboru użytkownika (zmiennej \code{COST\_TYPE}), Makefile dobierze odpowiednie opcję tak by biblioteka została skompilowana z~obsługą kosztu krawędzi o~wybranym typie.
W~tym celu wewnątrz pliku Makefile stworzono blok decydujący o~następującej strukturze:

\begin{lstlisting}[style=code,caption=Makefile - blok decydujący o zmiennej cost]
ifneq (,$(findstring s,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="short" -Dcost_fmt=\"%hd\" -Dcost_max=SHRT_MAX -Dcost_min=SHRT_MIN
endif
ifneq (,$(findstring us,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned short" -Dcost_fmt=\"%hd\" -Dcost_max=USHRT_MAX -Dcost_min=USHRT_MIN
endif
ifneq (,$(findstring i,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="int" -Dcost_fmt=\"%d\" -Dcost_max=INT_MAX -Dcost_min=INT_MIN
endif
ifneq (,$(findstring ui,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned int" -Dcost_fmt=\"%d\" -Dcost_max=UINT_MAX -Dcost_min=UINT_MIN
endif
ifneq (,$(findstring l,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long" -Dcost_fmt=\"%ld\" -Dcost_max=LONG_MAX -Dcost_min=LONG_MIN
endif
ifneq (,$(findstring ul,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned long" -Dcost_fmt=\"%ld\" -Dcost_max=ULONG_MAX -Dcost_min=ULONG_MIN
endif
ifneq (,$(findstring ll,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long long" -Dcost_fmt=\"%lld\" -Dcost_max=LLONG_MAX -Dcost_min=LLONG_MIN
endif
ifneq (,$(findstring ull,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned long long" -Dcost_fmt=\"%lld\" -Dcost_max=ULLONG_MAX -Dcost_min=ULLONG_MIN
endif
ifneq (,$(findstring f,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="float" -Dcost_fmt=\"%f\" -Dcost_max=FLT_MAX -Dcost_min=FLT_MIN
endif
ifneq (,$(findstring d,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="double" -Dcost_fmt=\"%f\" -Dcost_max=DBL_MAX -Dcost_min=DBL_MIN
endif
ifneq (,$(findstring ld,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long double" -Dcost_fmt=\"%Lf\" -Dcost_max=LDBL_MAX -Dcost_min=LDBL_MIN
endif
\end{lstlisting}

Przedstawiony powyżej wycinek pliku Makefile porównuje zawartość zmiennej \code{COST\_TYPE} z~ustalonymi wcześniej wartościami. Na tej podstawie dobiera odpowiednie zależności, przedstawione w~tabeli \ref{tab:dep}.

Funkcja \code{findstring} wyszukuje wystąpienia pierwszego argumentu wewnątrz drugiego argumentu.
Jeśli wyszukiwanie zakończyło się sukcesem, funkcja zwraca znaleziony ciąg znaków, w~przeciwnym wypadku wynik funkcji jest równy pustemu ciągowi (dlatego sprawdzany jest warunek \code{not equal} z~pustym pierwszym argumentem).

\begin{table}[htb]
\caption{Zależność poszczególnych zmiennych od wartości \code{COST\_TYPE}}
\label{tab:dep}
\begin{tabular}{ | c | c | c | c | c | }
	\hline
	COST\_TYPE  & cost\_type            & cost\_fmt  & cost\_max      & cost\_min      \\
	\hline \hline
	s           & short                 & \%hd       & SHRT\_MAX      & SHRT\_MIN      \\ \hline
	us          & unsigned short        & \%hd       & USHRT\_MAX     & USHRT\_MIN     \\ \hline
	i           & int                   & \%d        & INT\_MAX       & INT\_MIN       \\ \hline
	us          & unsigned int          & \%d        & UINT\_MAX      & UINT\_MIN      \\ \hline
	l           & long                  & \%ld       & LONG\_MAX      & LONG\_MIN      \\ \hline
	ul          & unsigned long         & \%ld       & ULONG\_MAX     & ULONG\_MIN     \\ \hline
	ll          & long long             & \%lld      & LLONG\_MAX     & LLONG\_MIN     \\ \hline
	ull         & unsigned long long    & \%lld      & ULLONG\_MAX    & ULLONG\_MIN    \\ \hline
	f           & float                 & \%f        & FLT\_MAX       & FLT\_MIN       \\ \hline
	d           & double                & \%f        & DBL\_MAX       & DBL\_MIN       \\ \hline
	ld          & long double           & \%Lf       & LDBL\_MAX      & LDBL\_MIN      \\ \hline
\end{tabular}
\end{table}

Posługiwanie się zmienną \code{cost} odbywa się dokładnie tak jak innymi zmiennymi typu skalarnego w~języku C.
Zalecane, aczkolwiek nie wymagane, jest korzystanie z~definicji \code{cost\_max}, \code{cost\_min} oraz \code{cost\_fmt}.
Wartości \code{cost\_max} oraz \code{cost\_min} zdefiniowane są w~plikach nagłówkowych \emph{limits.h} oraz \emph{float.h}. Ich załączenie wymagane jest w~każdym pliku \code{*.c} odwołującym się do zmiennej o~typie \code{cost\_type}.

Użytkownik chcący dodać własny typ może dokonać edycji pliku Makefile.
Powinien przypisać nazwę typu do deklaracji \code{cost\_type}, jej wartość minimalną do \code{cost\_min}, maksymalną do \code{cost\_max}, oraz format dla funkcji \code{printf} do \code{cost\_fmt}.
\begin{lstlisting}[style=coden,caption=Przykład nowego typu kosztu krawędzi]
ifneq (,$(findstring nowy,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type=nowy -Dcost_fmt=\"%format\" -Dcost_max=99 -Dcost_min=-99
endif

\end{lstlisting}
Należy pamiętać o~uciekaniu znaków przy definiowaniu wartości \code{cost\_fmt}.

Dzięki zaproponowanemu rozwiązaniu, biblioteka SCGL zdecydowanie zyskuje na wydajności zarówno czasowej jak i~pamięciowej, nie wprowadzając przy tym zbytniej komplikacji kodu.

\subsection{Algorytm Dijkstry}
ze najszybciej na kopcu kolejka prior, ze kolory, jak to u mnie działa i co można poprawić ze hash lista
\subsection{Testy jednostkowe - DejaGNU}
Testy jednostkowe są nieodłączną częścią każdego większego projektu programistycznego.
Jest to metoda testowania tworzonego oprogramowania poprzez weryfikowanie poprawności działania, każdego z~pojedynczych elementów (jednostek --- ang. \emph{units}) programu.
Testowany fragment poddawany jest testowi, który porównuje otrzymany wynik z~oczekiwanym (tak pozytywnym, jak i~niepozytywnym).
Testy jednostkowe pomagają weryfikować poprawność funkcji, mimo wprowadzanych zmian.
Programista wprowadzając kolejne zmiany, usprawniania, funkcjonalności --- po wykonaniu testów, może mieć pewność, iż jego zmiany w~kodzie nie wprowadziły kolejnych błędów.
Projektując bibliotekę SCGL, postanowiono wykorzystać właśnie tą metodę testowania, aby usprawnić przyszły rozwój platformy.

Jako platformę owych testów, zdecydowano wykorzystać się framework DejaGNU.
Przeznaczeniem DejaGNU, jest stworzenie warstwy abstrakcyjnej dla wszelakich testów programistycznych.
Napisany został z~wykorzystaniem pakietu \emph{expect}, który jest częścią języka \emph{Tcl} (ang. \emph{Tool Command Language}).
Expect, tworzy własny terminal, który symuluje działanie użytkownika obsługującego testujący program (najczęściej konsolowy).
Pozwala on na dość elastyczną interakcję, wygodne porównywanie oraz reagowanie na wyjście docelowego programu.

Konsekwentnie stosując zasadę \emph{KISS} (str. \pageref{kiss}), również testy jednostkowe dla biblioteki SCGL zostały napisane w~sposób jasny i przejrzysty.
Platforma testowa znajduje się w~katalogu \code{scgl/unit\_test/scgl.test}, są to dwa pliki:
\begin{itemize}
	\item tests.c --- plik zawierający kody aplikacji wykorzystujących bibliotekę SCGL
	\item test.exp --- plik definiujący testy, oraz wartości oczekiwane tych testów
\end{itemize}
Program budowany przy pomocy pliku \code{tests.c} zawiera 23 podprogramy, każdy z~nich korzysta/testuje konkretną ,,jednostkę'' biblioteki SCGL.
Program ten oczekuje na wpisanie przez użytkownika: rodzaju podprogramu (wybór modułu), oraz jego numeru (wybór jednostki), a~następnie uruchamia przykładowy kod.
DejaGNU, uruchamiając kolejne testy, porównuje wartości oczekiwane, z~tymi zwróconymi przez program \code{tests.out}.
Przy pomocy wyżej opisanych plików, testowane są:
\begin{enumerate}
	\item Tworzenie/usuwanie węzłów
	\item Ustawianie/pobieranie ID węzła
	\item Tworzenie/usuwanie krawędzi
	\item Ustawianie/pobieranie kosztu krawędzi
	\item Dodawanie/pobieranie/usuwanie węzła do/z krawędzi
	\item Dodawanie/pobieranie/usuwanie krawędzi do/z węzła
	\item Zliczanie krawędzi w węźle
	\item Wykonywanie funkcji na każdej krawędzi w węźle
	\item Tworzenie/usuwanie atrybutu krawędzi
	\item Ustawianie/pobieranie klucza atrybutu
	\item Ustawianie/pobieranie wartości atrybutu
	\item Dodawanie/pobieranie/usuwanie atrybutu do/z krawędzi
	\item Zliczanie atrybutów krawędzi
	\item Wykonywanie funkcji na każdym atrybucie
	\item Zmiana krawędzi na (nie)skierowaną
	\item Tworzenie/usuwanie grafu
	\item Ustawianie/pobieranie ID grafu
	\item Dodawanie/pobieranie/usuwanie węzła do/z grafu
	\item Dodawanie/pobieranie/usuwanie krawędzi do/z grafu
	\item Zliczanie węzłów/krawędzi w grafie
	\item Kopiowanie grafów
	\item Wykonywanie algorytmu Dijkstry na grafie skierowanym
	\item Wykonywanie algorytmu Dijkstry na grafie nieskierowanym
\end{enumerate}

\begin{lstlisting}[style=code,caption=Plik definicji testów jednostkowych platformy DejaGNU]
global TEST_APP
set test_data {
	{"vertex create/destroy"        "v 1"   "^test 0$"}
	{"vertex set/get ID"            "v 2"   "^test_get test_set$"}
	{"edge create/destroy"          "e 1"   "^0 1 123 123 0$"}
	{"edge get/set cost"            "e 2"   "^123 321$"}
	{"edge add/get/del vertex"      "e 3"   "^\\d+ 0 0 \\d+ 0 \\d+ \\d+ 0$"}
	{"vertex add/get/del edge"      "v 3"   "^\\d+ 0 0 0 \\d+ 0$"}
	{"vertex edges count"           "v 4"   "^0 0 1 0 1 1$"}
	{"vertex foreach edge"          "v 5"   "^1 2 $"}
	{"attribute create/destroy"     "a 1"   "^key value 0$"}
	{"attribute get/set key"        "a 2"   "^key key2.$"}
	{"attribute get/set value"      "a 3"   "^val1 val2.$"}
	{"edge add/get/del attributes"  "e 4"   "^key1 val1 val1 0$"}
	{"edge attributes count         "e 5"   "^1 0$"}
	{"edge foreach attribute"       "e 6"   "^key val.$"}
	{"edge set/get (un)directed"    "e 7"   "^0 123 1 1 \\d+ 123 1$"}
	{"graph create/destroy"         "g 1"   "^G1 0$"}
	{"graph get/set ID"             "g 2"   "^G1 G2.$"}
	{"graph add/get/del vertex"     "g 3"   "^2 V2 V1 1 0 V2.$"}
	{"graph add/get/del edge"       "g 4"   "^2 123 321 1 321 0$"}
	{"graph vertexes/edges count"   "g 5"   "^0 0 2 2$"}
	{"graph copy"                   "g 6"   "^0 1 1 0 1 V2 V2 0 1$"}
	{"dijkstra directed graph       "d 1"
		"^0, 0, 0, 4, 5, 1, 1, 6, 7, 8, 9, 9, 3, 0, 1, 1, 32, 30, 15, 5, 13, 22, 31, 37, 47, 49,.$"}
	{"dijkstra undirected graph"    "d 2"
		"^0, 0, 0, 11, 3, 1, 1, 6, 7, 11, 9, 2, 9, 0, 1, 1, 19, 21, 15, 5, 13, 22, 24, 30, 8, 29,.$"}
}

foreach pattern $test_data {
	eval "spawn $TEST_APP [lindex $pattern 1]"
	expect {
		-re [lindex $pattern 2] { pass [lindex $pattern 0] }
		default { fail [lindex $pattern 0] }
	}
\end{lstlisting}
Plik opisujący procedurę testowania \code{test.exp}, przechowuje tabelę \code{test_data} (linie 2--28) zawierającą kolejno: nazwę testu, argumenty przekazywane programowi oraz wartości oczekiwane (zapisane przy pomocy języka \emph{regexp}).
Część wykonawcza testu, to pętla \code{foreach} wywołująca kolejno testy z~tabeli \code{test_data} oraz porównująca wyniki programu z~wartościami oczekiwanymi.
Testy wywoływane są w~kolejności, która zapewnia spójność logiczną całości, np.: test dodawania atrybutu do krawędzi, jest zależy od testu tworzenia krawędzi oraz od testu tworzenia atrybutu.
Testy algorytmu Dijkstry są przeprowadzane na grafach zaprezentowanych na rysunkach %TODO ref, %TODO ref.
%RYS 1
%RYS 2

Wymogiem niezbędnym do uruchomienia testów jest kompilujący się kod biblioteki SCGL, oraz posiadanie zainstalowanego w~systemie pakietu DejaGNU.
Testy uruchamiane są przez Makefile znajdujący się w~katalogu \code{scgl/}, można dokonać tego w~następujący sposób:
\begin{lstlisting}[style=coden]
make tests
\end{lstlisting}
Polecenie to wywoła kompilację pliku \code{scg/unit_tests/scgl.test/tests.c} oraz uruchomienie programu \code{runtest} (część pakietu DejaGNU) z~plikiem definicji testów: \code{test.exp}.
Jak zostało wcześniej wspomniane, testy jednostkowe są bardzo ważnym elementem oprogramowania, które będzie rozwijane.
Należy jednak pamiętać, że w~samych testach również może wkraść się błąd, należy je zatem tworzyć ze szczególną starannością.

\section{Instrukcja użytkownika}
\subsection{Kompilacja}
\label{chap:make}
Makefile jak zbudowany, co buduje, co kasuje, ze dokumentacje zbudujemy wchodząc do doc/latex/make 
\subsection{Interfejs programisty - API}
opisać jak są zbudowane funkcje ze scgl\_moduł\_funkcja, jakie są najważniejsze,ze create/destroy, ze destroy kasuje i ustawia na NULL, jak używać atrybutów przykłady foreach 

\chapter{Porównanie z istniejącymi rozwiązaniami}
\label{chap:tests}
Jak wspomniano we wstępnie niniejszej pracy, teoria grafów jest jedną z najpotrzebniejszych dziedzin matematyki w~informatyce.
Ze względu na szeroką gamę zastosowań, powstało wiele rozwiązań implementujących w~mniejszym, lub większym stopniu ową dziedzinę.
Są to biblioteki napisane w~niemal każdym języku programowania: C, C++, D, Python, Haskell, Matlab.

Jednym z~głównych celów pracy, było stworzenie oprogramowania zużywającego jak najmniej zasobów komputera, zarówno pamięciowych jak i~obliczeniowych.
Aby potwierdzić spełnienie założeń należy porównać stworzoną bibliotekę, z~innymi rozwiązaniami.
Do porównań wybrane zostały dwie najpopularniejsze biblioteki grafów:
\begin{itemize}
	\item Boost::BGL --- część ogromnej biblioteki Boost, napisanej w~języku C++
	\item igraph --- oprogramowanie napisane w~języku C
\end{itemize}

\begin{description}
\item[Boost::BGL]
Biblioteka BGL (ang. \emph{Boost Graph Library}), została stworzona przez Jeremiego Sieka oraz grupę z~uniwersytetu Notre Dame w~USA.
Wchodzi w~skład bibliotek Boost, zawiera szablony reprezentujące grafy oraz zbiór kilkudziesięciu algorytmów grafowych.
Grafy są dostarczane w postaci generycznej, dzięki czemu z wierzchołkiem, krawędzią lub całym grafem można związać obiekt lub obiekty dowolnego typu.
Szablony z biblioteki boost::graph wykorzystują kolekcje ze standardowej biblioteki szablonów (STL).

Graf w~Boost::BGL może być reprezentowany listą sąsiedztwa, a~także przez macierz sąsiedztwa albo w~specjalnej postaci skompresowanej.
W~najprostszym przypadku, gdy krawędzie są przechowywane w wektorze, identyfikatorem wierzchołka jest liczba całkowita (indeks).

\item[igraph]
\emph{igraph} jest przestronną biblioteką grafów, wspierającą aplikacje pisane w~językach takich jak: C, R, Python, czy Ruby.
Zawiera funkcje implementujące klasyczne problemy teorii grafów, takie jak minimalne drzewa rozpinające, czy algorytmy najkrótszych ścieżek.
Potrafi również generować kilkanaście rodzajów grafów, a~także eksportować je do wielu formatów obsługiwanych przez oprogramowanie graficzne.

Jest najpopularniejszą biblioteką grafów napisaną w~języku C.
\end{description}

\section{Testy porównawcze}
Porównania wcześniej wymienionych bibliotek z~biblioteką SCGL dotyczyły wydajności obliczeniowej oraz pamięciowej, tych rozwiązań.
Na potrzeby testów stworzono trzy scenariusze testowe:
\begin{enumerate}
	\item Stopnia zużycia pamięci operacyjnej --- dokładniej maksymalnego użycia sterty (ang. \emph{heap}).
	\item Szybkości tworzenia oraz usuwania obiektów.
	\item Szybkości wykonywania algorytmu Dijkstry --- obliczania najkrótszych ścieżek.
\end{enumerate}
Każdy z~nich przeprowadzony został w~dwóch wariantach:
\begin{itemize}
	\item z wykorzystaniem krawędzi skierowanych
	\item z wykorzystaniem krawędzi nieskierowanych
\end{itemize}
Pliki źródłowe testów, znajdują się w~katalogu \code{perf\_tests}.
Przedrostek, w~nazwie pliku, wskazuje na rodzaj testu, następna litera \code{d} na wariant ,,skierowany'' (\code{u} na ,,nieskierowany'') a~ostatni znak na wykorzystaną bibliotekę: \code{s} --- SCGL; \code{b} --- BGL; \code{i} --- igraph.

Wszystkie testy zostały przeprowadzone w~tych samych warunkach.
Badania wykonano na jednordzeniowym procesorze Intel Celeron M420 taktowanym 1,6GHz oraz na pamięci RAM 400MHz (5 -- 5 -- 5 -- 18 @ CL -- RCD -- RP -- RAS).
System pod którym przeprowadzono eksperymenty to GNU/Linux Arch z~jądrem w~wersji: 3.4.0-1.
Programy zostały skompilowane przy użyciu:
\begin{itemize}
	\item gcc 4.7.0 z następującymi flagami: -s -Os
	\item g++ 4.7.0 z następującymi flagami: -s -Os
\end{itemize}

Testy mające na celu porównanie użycia czasu procesora, powtarzane były w~pętli tysiąckrotnie, a~następnie uśredniane.
Skrypt odpowiadający za powtarzanie testu przedstawiony jest na poniższym listingu:
%SKRYPT
Jak już zostało wspomniane powtarza on wykonanie polecenia (przyjmowanego jako argument skryptu) 1000 razy, sumując czas użycia procesora, zmierzony programem \emph{time} (wartości \emph{user time}).
Testy porównujące maksymalne użycie sterty, wykonane zostały przy pomocy programu \emph{valgrind} 
%TODO footnote do czego służy.

Test mający na celu porównać poziom wykorzystania sterty przez wybrane biblioteki, polegał na stworzeniu jednego grafu, 1000 krawędzi oraz 1001 węzłów.
Żaden ze stworzonych elementów nie przechowywał dodatkowych atrybutów.

%\usepackage{multicol}
%\begin{document}
%\begin{multicols}{2}[LISTING]
%http://tex.stackexchange.com/questions/34098/two-column-code-listings-in-appendix-in-a-one-column-report
%\end{multicols}

\begin{table}[htb]
\caption{Wyniki pomiaru wykorzystania sterty}
\label{tab:mem_size}
\centering
\begin{tabular}{ | c | r | r | }
	\hline
	\multirow{2}{*}{Nazwa biblioteki } & \multicolumn{2}{|c|}{Zużycie sterty w~bajtach (ilość alokacji)} \\
	\cline{2-3}
		& Graf skierowany & Graf nieskierowany \\
	\hline \hline
	SCGL    & 76~048  (2002) & 124~048 (3003) \\ \hline
	BLG     & 44~753  (2012) &  76~745 (3012) \\ \hline
	igraph  & 112~160 (0021) & 112~160 (0021) \\ \hline
\end{tabular}
\end{table}

Jak można zauważyć w~powyższej tabeli, biblioteki BGL oraz SCGL wykorzystują więcej pamięci dla grafów nieskierowanych (wszystkie krawędzie są nieskierowane), niż dla grafów w pełni skierowanych.
W~przypadku SCGL wynika to z~faktu, iż dostosowana ona jest do przetrzymywania krawędzi skierowanych.
Obiekty nieskierowane tworzone są poprzez dołączenie do krawędzi skierowanej jej odpowiednika z~zamienionymi końcami (od/do).
Aby ograniczyć zużycie pamięci, odpowiednik ten nie przechowuje informacji na temat atrybutów.
Nie jest to wymagane, gdyż krawędź ta (odpowiednik), jest niejako zawieszony w~powietrzu i~nie jest dostępny z~poziomu samego grafu.

Wyniki pomiarów, zamieszczone w~tabeli \ref{tab:mem_size}, ukazują także, że zużycie pamięci dla dostarczonego przez autora pracy rozwiązania, są dużo mniejsze niż biblioteki igraph --- w~przypadku grafów skierowanych.
Niestety nie udało się zmniejszyć zapotrzebowania, poniżej poziomu biblioteki BGL, mimo że osiągnięto porównywalną liczbę alokacji.
Program \code{valgrind} pokazał w~przypadku kodu stosującego oprogramowanie igraph, bardzo niską liczbę alokacji (21).
Może to wynikać z~faktu zastosowania w~tym rozwiązaniu niestandardowego mechanizmu przydzielania pamięci (.

Celem kolejnego z~przeprowadzonych testów, było porównanie czasu procesora, jaki zostanie zużyty do tysiąckrotnej alokacji i~uwolnienia obiektów z~poprzedniego testu (1~graf, 1000 krawędzi, 1001 węzłów).
%\usepackage{multicol}
%\begin{document}
%\begin{multicols}{2}[LISTING] to jest bezsensu :/, może tylko przykład w SCGL, albo w pseudokodzie a link do CD :D 
%http://tex.stackexchange.com/questions/34098/two-column-code-listings-in-appendix-in-a-one-column-report
%\end{multicols}

\begin{table}[htb]
\caption{Wyniki pomiaru wykorzystania czasu procesora podczas tworzenia/niszczenia obiektów}
\label{tab:mem_speed}
\centering
\begin{tabular}{ | c | c | c | }
	\hline
	\multirow{2}{*}{Nazwa biblioteki } & \multicolumn{2}{|c|}{Wykorzystanie czasu procesora w sek.} \\
	\cline{2-3}
		& Graf skierowany & Graf nieskierowany \\
	\hline \hline
	SCGL    & 0.384 & 0.560 \\ \hline
	BLG     & 0.563 & 0.740 \\ \hline
	igraph  & 0.295 & 0.295 \\ \hline
\end{tabular}
\end{table}
Jak wynika z~powyższych rezultatów, niska ilość alokacji biblioteki igraph przekłada się na szybkość wykonywania tych operacji.
Czasy osiągane przez to oprogramowanie są niemal dwukrotnie niższe, niż w~przypadku biblioteki BGL.
Ponownie w~przypadku SCGL oraz BLG, wyniki dla grafów nieskierowanych są gorsze niż dla skierowanych.
Biblioteka SCGL osiągnęła niższe czasy tworzenia i czyszczenia pamięci niż jej odpowiednik napisany w~C++.

Ostatni test polegał na wytyczeniu najkrótszych ścieżek z~pierwszego węzła w~grafie (indeks zerowy), do wszystkich pozostałych, przy zastosowaniu algorytmu Dijkstry (opisanego w~rodziale %REF).
Podobnie jak poprzednie testy, ten bazował na dwóch grafach: skierowanym oraz nieskierowanym, oba o~nieujemnych kosztach poszczególnych krawędzi. %TODO ref do fig

%\usepackage{multicol}
%\begin{document}
%\begin{multicols}{2}[LISTING]
%http://tex.stackexchange.com/questions/34098/two-column-code-listings-in-appendix-in-a-one-column-report
%wstawić kod z komentarzem w miejscu tworzenia grafu
%\end{multicols}
Z~powodu niewielkich rozmiarów badanych grafów, operacja wyznaczania ścieżek została powtórzona 10000 razy.

\begin{table}[htb]
\caption{Wyniki pomiaru wykorzystania czasu procesora podczas wykonywania algorytmu Dijkstry}
\label{tab:dijkstra}
\centering
\begin{tabular}{ | c | c | c | }
	\hline
	\multirow{2}{*}{Nazwa biblioteki } & \multicolumn{2}{|c|}{Wykorzystanie czasu procesora w~sek.} \\
	\cline{2-3}
		& Graf skierowany & Graf nieskierowany \\
	\hline \hline
	SCGL    & 0.037 & 0.057 \\ \hline
	BLG     & 0.035 & 0.050 \\ \hline
	igraph  & 0.477 & 0.800 \\ \hline
\end{tabular}
\end{table}
Jak można zauważyć w~powyższej tabeli, wyniki biblioteki igraph znacząco odstają od rozwiązań SCGL oraz BGL.
Powód tego faktu pozostaje nieznany, jednakże może to wynikać ze sposobu przechowywania informacji (na temat grafu) w~pamięci.
Stworzona na potrzeby celów pracy, biblioteka SCGL, osiąga porównywalne czasy do biblioteki BGL.
Warto zauważyć, iż SCGL korzysta z~mniej wydajnych list powiązanych, a~biblioteka BGL była rozwijana i~udoskonalana przez wiele lat.

Jako ciekawostkę można dodać, że kody źródłowe oparte na bibliotece BGL, jak i~wszystkie rozwiązania oparte na języku C++, mają przeciętnie 3---4 razy dłuższe czasy kompilacji, niż ich odpowiedniki w~języku C~(zarówno dla biblioteki igraph, jak i~SCGL).

\chapter*{Podsumowanie}
ze można zmniejszyć narzut, ze można usprawnić kopiec, ze można dodać haslistę  ze można dodać algorytmy, 
   ze działa ze dynamiczne ze atrybuty (w igraph to dopiero eksperymentalna opcja), ze szybkie i w miarę małe, 
\addcontentsline{toc}{chapter}{Podsumowanie}
\chapter*{Summary}
\addcontentsline{toc}{chapter}{Summary}
\bibliography{thesis}
\chapter*{Dodatek A. Dokumentacja}
\addcontentsline{toc}{chapter}{Dodatek A. Dokumentacja}
\chapter*{Dodatek B. Oświadczenie}
\addcontentsline{toc}{chapter}{Dodatek B. Oświadczenie}
\chapter*{Dodatek C. Opis zawartości płyty CD}
\addcontentsline{toc}{chapter}{Dodatek C. Opis zawartości płyty CD}
\label{chap:cd}

Cel i \index{lol}zakres pracy\cite{bib:test}

\listoffigures
\listoftables
\lstlistoflistings
%\printindex

\end{document}
