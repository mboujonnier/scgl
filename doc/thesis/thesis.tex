\documentclass[a4paper,12pt]{thesis}
\usepackage{listings}

\lstdefinestyle{line}{
	language=C,
	basicstyle=\ttfamily,
}

\lstdefinestyle{code}{
	language=C,
	basicstyle=\ttfamily\scriptsize,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	captionpos=t,
	breaklines=true,
	frame=single,
	breakatwhitespace=false,
}

\lstdefinestyle{coden}{
	language=C,
	basicstyle=\ttfamily\scriptsize,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	captionpos=t,
	breaklines=true,
	frame=single,
	breakatwhitespace=false,
}

\newcommand\code[1]{\lstinline[style=line]{#1}}
\renewcommand{\lstlistlistingname}{Spis listingów}

\autor{Patryk Kwiatkowski}
\tytul{Podstawowa biblioteka grafów~w~C}
\tytulAng{Simple C~graph library}
\promotor{dr inż. Ireneusz Szcześniak}
\rok{2012}
\kierunek{Informatyka}
\specjalnosc{Sieciowe Technologie Informatyczne}
\numerAlbumu{101510}
\studia{stacjonarne}
\stopien{II}

\begin{document}

\stronaTytulowa

\tableofcontents

\chapter*{Cel pracy}
\addcontentsline{toc}{chapter}{Cel pracy}
Cel i \index{lol}zakres pracy\cite{bib:test}

\chapter*{Wstęp}
\addcontentsline{toc}{chapter}{Wstęp}

Systemy nawigacji GPS, sieć Internet, gry komputerowe, translatory języków obcych, biologia, chemia, socjologia --- to wszystko, i~wiele innych dziedzin życia, łączy jeden wspólny element, teoria grafów.
Kiedy rozwój informatyki pozwolił na reprezentowanie grafów za pomocą komputera, okazało się, że algorytmy na nich oparte znajdują wiele praktycznych zastosowań.
Grafy są jednymi z~najbardziej wszechobecnych modeli zarówno świata naturalnego jak i~stworzonego przez człowieka.

Oprogramowanie oparte na analizie grafów znalazło zastosowanie w~wyznaczaniu trasy pomiędzy punktami na mapie, czy najszybszej drogi ewakuacji z~kompleksu budynków.
Przedstawienie sieci komputerowych w~postaci grafów pozwoliło na stworzenie programów usprawniających przepływ pakietów w~Internecie.
W fizyce materii skondensowanej, trójwymiarowa struktura skomplikowanych symulacji struktur atomowych może zostać zbadana poprzez gromadzenie danych statystycznych dotyczących właściwości związanych z~topologią atomów przedstawioną właśnie przy użyciu grafów.
Ta dziedzina matematyki jest równie przydatna w~biologii, gdzie wierzchołek może reprezentować regiony, w~których niektóre gatunki istnieją, a~krawędzie ścieżki migracji. Informacja ta jest ważna, gdyż patrząc na powstałe wzorce, można zbadać wpływ rozprzestrzeniających się chorób, pasożytów czy zmiany ruchów na inne zwierzęta.

Dzięki możliwością jakie dają dzisiejsze komputery w~przetwarzaniu informacji, powstało wiele bibliotek obsługujących obliczenia oparte o~teorię grafów.
Rozwiązania te pojawiają się w~niemal każdym języku programowania, od \emph{C++}, przez \emph{D}, aż do \emph{Pythona} czy \emph{Matlaba}.
Tematyka teorii grafów, ze względu na szeroką gamę zastosowań oraz dużą przydatność --- zwłaszcza przy analizie, projektowaniu oraz udoskonalaniu sieci komputerowych --- została wybrana przez autora, jako temat przewodni niniejszej pracy naukowej.
Mimo istnienia dużej ilości bibliotek komputerowych implementujących zagadnienia tej tematyki, niewiele z~nich cechuje się prostotą oraz przejrzystością kodu źródłowego.
Zaś wiele z~nich zazwyczaj zużywa wiele zasobów pamięciowych, oraz działa względnie powolnie.
Potrzeba ograniczenia zużywanych zasobów, oraz stworzenia projektu prostego i~czytelnego, była główną motywacją autora do podjęcia się stworzenia ,,\emph{Prostej biblioteki grafów w~C}''.

Rozdział pierwszy niniejszej pracy zawiera wiedzę teoretyczną posiadaną, lub zebraną, przez autora pracy na potrzeby realizacji wcześniej przedstawionych celów.
W~rozdziale tym wymienia się i~opisuje pojęcia związane z~szeroko pojętą teorią grafów, kładąc szczególny nacisk na wykorzystywane później jej elementy.

Drugi rozdział pracy zawiera szczegółowy opis zaprojektowanej biblioteki.
Wyjaśnia powody wyboru konkretnych technologii do realizacji obranych celów.
W~rozdziale tym przedstawiona została budowa poszczególnych modułów, sposób przechowywania informacji oraz metody usprawniające pracę przy dalszym rozwoju biblioteki.
Zawiera on też kilka przykładów wykorzystania interfejsu użytkownika.

Rozdział trzeci pracy przedstawia porównanie stworzonego na cele pracy projektu, z~istniejącymi już rozwiązaniami.
Porównania te zostały przeprowadzone pod kątem ilości zużywanej pamięci, oraz czasu jaki jest potrzebny na wykonanie podstawowych funkcji tego typu biblioteki.

Dodatkowo na końcu pracy, jako załącznik, zamieszczona została automatycznie wygenerowana, anglojęzyczna dokumentacja niniejszej biblioteki.

\chapter{Wybrane zagadnienia teorii grafów}
graf, krawędź, węzeł, rodzaje grafów (nieskierowany skierowany), zastosowania grafów, modelowanie sieci 
\section{Algorytm Dijkstry}
pseudokod, po co, złożoność, porównanie do innych (złożoność)


%\chapter{Biblioteki w systemach Unix / Linux}
%co to, po co 
%\section{Statyczne}
%zalety / wady jak tworzyc
%\section{Współdzielone}
%zalety /wady umiejscowienie


\chapter{Realizacja biblioteki}
Do zrealizowania postawionych w~pracy celów zaprojektowano oraz zaimplementowano bibliotekę nazwaną Simple C~Graph Library, dalej określaną akronimowi SCGL.
Projekt ten stworzony został w~oparciu o~język C~oraz jego bibliotekę standardową (w systemach Unix/Linux: \emph{GNU libc - glibc}).

Wyboru tego dokonano przede wszystkim ze względu na możliwość redukcji wszelkich narzutów wynikających z~cech charakterystycznych dla języków obiektowych (dziedziczenie, polimorfizm, szablony).
Dodatkowym atutem było bardzo dobre wsparcie kompilatorów oraz szeroki wybór dostępnych narzędzi dla języka C.

Projekty takie jak ten przedstawiony w niniejszej pracy często charakteryzują się dynamicznym rozwojem, zwłaszcza w początkowych fazach tworzenia.
W~celu zapewnienia poprawności zaimplementowanych już funkcjonalności, zdecydowano się skorzystać z~mechanizmu testów jednostkowych oraz platformy \emph{DejaGNU}.

Dodatkowo biblioteka wykorzystuje program \emph{make} oraz pliki reguł \emph{Makefile} do automatyzacji procesu kompilacji.

Podczas projektowania każdego z~modułów biblioteki wykorzystano wiedzę zawartą w publikacjach TODO, TODO oraz stosowano się do reguły KISS (ang. \emph{Keep It Simple, Stupid}), która traktuje o tym, że im coś jest prostsze (jako koncept, oraz jako wykonanie) tym lepiej TODO (kiss).
\section{Budowa projektu}
\subsection{Diagram klas}
powiązanie klas i opisać każdą z osobna
\subsection{Struktura plików}
/src /include ?
\section{Szczegóły implementacji}

\subsection{Linux Kernel List}

Zjawiska modelowane przy wykorzystaniu teorii grafów, charakteryzują się zazwyczaj dużą dynamiką zmian w~czasie.
Przykładowo, w~miarę rozwoju firmy na rynku, rozwija się jej infrastruktura wewnętrzna --- struktura sieci komputerowej jest rozbudowywana o~nowe lokacje, co za tym idzie urządzenia trasujące (przedstawiane jako węzły grafu).
Fakt ciągłych zmian w~budowie grafów, narzuca niejako implementującej go bibliotece, wymaganie obsługi tego typu zdarzeń.
Musi być ona w~stanie dynamicznie zmienić rozmiary struktur, tak aby w~każdej chwili dodać (lub usunąć) wybrane elementy.

W~językach takich jak \emph{C++} najczęściej do tego celu wykorzystywane są tzw. wektory, czyli tablice o~dynamicznych rozmiarach.
Korzystając z~nich nie musimy podawać, podczas tworzenia, ilości elementów jakie będą w~nich przechowywane.
A~w~trakcie dodawania/usuwania elementów, rozmiar tablicy dostosowuje się automatycznie.

Wybrany do realizacji celów pracy język C, nie posiada wbudowanej obsługi podobnych mechanizmów wbudowanych w~standardową bibliotekę.
Istnieje co prawda możliwość rozszerzania rozmiaru tablicy (przy pomocy funkcji \code{realloc}), jednakże jest to mało wydajny mechanizm, zwłaszcza przy dużej ilości operacji dodawania/usuwania.
Innym rozwiązaniem byłyby biblioteki zewnętrze, przeznaczone dla języka C, dodające brakującą funkcjonalność.
Użycie ich może jednak wiązać się z~dodatkowymi dużymi narzutami na rozmiar biblioteki, zużywaną pamięć lub szybkość działania.
Aby zniwelować wpływ (negatywny) kodu ,,trzeciego'' na SCGL, postanowiono wykorzystać mechanizm list dowiązanych do przechowywania informacji na temat wszystkich krawędzi (ich atrybutów) oraz węzłów w~grafie.
Zasada działania jak i~implementacja tego typu list jest niezwykle prosta, a~jednocześnie nie wpływa znacząco na ilość zużywanej pamięci.

Wg klasycznego podejścia do problemu, lista jest to obiekt (struktura/klasa) zawierająca dane właściwie, oraz wskaźnik na kolejny obiekt tego samego typu.
\begin{lstlisting}[style=code,caption=Idea listy powiązanej w~C]
struct list {
	struct list *prev
	struct list *next;
	void *data;
};
\end{lstlisting}
Posiadając wskaźnik, wskazujący na pierwszy element listy (\code{head}), możemy otrzymać dostęp do kolejnych danych przechowywanych wewnątrz listy poprzez wyłuskiwanie kolejnych wskaźników (\code{next}/\code{prev}).

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{linkedlist.eps}
		\caption{Kolejne elementy listy powiązanej}
	\end{center}
\end{figure}

%TODO czym się charakteryzuje jakie czasy i O(n)

W~niniejszej pracy postanowiono jednak skorzystać z~mechanizmu nazwanego \emph{Linux Kernel List}.
Jest to implementacja listy dowiązanej, (dwukierunkowej; cyrkulacyjnej), wykorzystywana w~jądrze (ang. \emph{kernel}) systemów operacyjnych \emph{Linux}
Jest to jeden plik nagłówkowy (\code{*.h}) języka C.
Zawiera on definicję struktury \code{list\_head} oraz definicje i~deklaracje funkcji oraz makr preprocesora, obsługujących tą strukturę.
Linux Kernel Lists są wyjątkowe, z~powodu trochę innego podejścia do tematu.
Struktura \code{list\_head} zawiera jedynie informację (wskaźniki) na następny oraz poprzedni element listy.
Brak jest tu standardowego pola \code{data}, które przechowywałoby informacje użytkownika (tak jak jest to realizowane w~standardowej implementacji listy).
W~rozwiązaniu Linuksowym, realizacja listy daje złudzenie, że lista zawarta jest w~obiekcie który łączy (który powinien być wewnątrz niej).
Na przykład, jeśli chce się stworzyć listę powiązaną struktur \code{my\_struct}, należy zrobić to w~następujący sposób:
\begin{lstlisting}[style=code,caption=Przykład tworzenia listy powiązanej za pomocą Kernel Lined List]
struct my_struct{
	struct list_head list; /* struktura kernel list */
	int my_data;
	void *my_void;
};
\end{lstlisting}
Gdzie struktura \code{list\_head} zbudowana jest następująco:
\begin{lstlisting}[style=code]
struct list_head{
	struct list_head *prev;
	struct list_head *next;
};
\end{lstlisting}
Dołączamy strukturę listy do własnego obiektu, zamiast, obiekt do struktury listy.
Dodając kolejne elementy listy, łączymy ze sobą tak naprawdę kolejne struktury \code{list\_head}.

Najważniejsze przy obcowaniu z~listami jądra Linuksa to:
\begin{itemize}
	\item Lista jest wewnątrz obiektów, które chcemy razem połączyć.
	\item Można umieścić strukturę \code{list\_head} w~każdym miejscu własnej struktury.
	\item Zmienna typu \code{list\_head} może mieć dowolną nazwę.
	\item Rozwiązanie to nie ogranicza nas do jednej listy, na cały kod źródłowy.
\end{itemize}
Ponieważ jest to mechanizm zapożyczony z jądra systemu Linux, istnieje pewność iż jest dobrze przetestowane, przenośne, szybkie oraz zajmuje niewiele pamięci.
Warto również wspomnieć, iż ten sam plik nagłówkowy, dostarcza podstaw do implementacji tablic asocjacyjnych (ang. \emph{hash list}).

Potrzebne były pewne modyfikacje, aby plik nagłówkowy \code{list.h} dostosować do zwykłego kodu, przestrzeni użytkownika (ang. \emph{userspace}):
\begin{enumerate}
	\item Została zmieniona definicja pliku nagłówkowego \code{list.h}
	\item Zostały usunięte załączone pliki nagłówkowe
	\item Zostały dodane struktury znajdujące się w~pliku \code{types.h}
	\item Wywołanie makra \code{offsetof} z~pliku \code{stddef.h}, zostało zamienione na jego treść
	\item Zmienne \code{LIST\_POISON1} oraz \code{LIST\_POISON2} zostały zastąpione przez wskaźnik na NULL --- sens pozostaje taki sam
\end{enumerate}
Dodatkowo na potrzeby biblioteki SCGL dopisana została funkcja \code{list\_count} obliczająca ilość elementów wewnątrz listy:
\begin{lstlisting}[style=code,caption=Ciało funkcji {list\_count}]
static inline unsigned int
list_count(const struct list_head *head) {
	unsigned int i = 0;
	struct list_head *j;
	list_for_each(j, head) {
		++i;
	}
	return i;
}
\end{lstlisting}

Jak już zostało wspomniane, łącząc kolejne elementy, łączymy ze sobą struktury \code{list\_head}.
Wymusza to na programiście, zmianę toku myślenia.
Chcąc przechowywać listę krawędzi wewnątrz struktury grafu, musimy w~obu tych obiektach dołączyć strukturę \code{list\_head}.
Im więcej list krawędzi chce się stworzyć, tym więcej zmiennych typu \code{list\_head} należy wpisać w~budowę obiektu.
I~tak biblioteka SCGL posiadając pięć list:
\begin{enumerate}
	\item krawędzi w grafie,
	\item węzłów w grafie,
	\item krawędzi wchodzących do węzła,
	\item krawędzi wychodzących z węzła,
	\item atrybutów krawędzi.
\end{enumerate}
Musi mieć wpisane w~struktury dziesięć, zmiennych typu \code{list\_head}.

\begin{lstlisting}[style=code,caption=Zastosowanie Linux Kernel List na przykładzie struktur biblioteki SCGL]
/** attribute object */
struct scgl_attr {
	list_head_t list;
};

/** edge object */
struct scgl_edge {
	list_head_t from_list;
	list_head_t to_list;
	list_head_t owner_list;
	list_head_t attributes;
};

/** vertex object */
struct scgl_vertex {
	list_head_t in;
	list_head_t out;
	list_head_t owner_list;
};

/** graph object */
struct scgl_graph {
	list_head_t vertexes;
	list_head_t edges;
};
\end{lstlisting}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{listconnection.eps}
		\caption{Diagram połączeń pomiędzy listami dowiązanymi biblioteki SCGL}
	\end{center}
\end{figure}

Zastosowanie list powiązanych, zapożyczonych z~jądra Linuksa, pozwoliło na oszczędzenie pamięci oraz szybkości działania.
Przyśpieszyło i ułatwiło to również sam proces tworzenia biblioteki SCGL.
Nie warto tworzyć kolejnych rozwiązań od nowa, jeśli istniejące są dobrze zaimplementowane.

\subsection{Statycznie kompilowany typ zmiennej}
Sporym oraz ciekawym wyzwaniem projektowym okazał się niepozorny atrybut kosztu (wagi) krawędzi, a~właściwie typ zmiennej przechowującej tą wartość.
Jak już zostało wcześniej wspomniane, element ten wykorzystywany jest przy wyborze ścieżki pomiędzy zadanymi węzłami.
Wymaganiem postawionym przed biblioteką SCGL była elastyczność typu zmiennej określającej koszt krawędzi.
Biblioteka powinna pozwalać użytkownikowi na wybór typu owego parametru według własnych preferencji, bez ingerencji w~sam kod projektu.

Problem ten dotyka tematyki paradygmatu programowania uogólnionego (generycznego, ang, \emph{generic programming}).
Pozwala on na pisanie kodu programu bez wcześniejszej znajomości typów danych, na których kod ten będzie pracował.
W~językach Java, C\#, Haskell służą do tego typy generyczne (typ ten pojawia się również w C++ dzięki zastosowaniu biblioteki \emph{boost::any}).
Zaś w~językach takich jak C++ czy D, funkcjonalność tą można zrealizować poprzez zastosowanie mechanizmu szablonów (ang. \emph{template}).
Podczas kompilacji następuje tak zwana konkretyzacja szablonu (ang. \emph{template instantiation}), podczas której kompilator na podstawie typów danych przekazanych wzorcowi generuje kod właściwy do obsługi danego typu.
Dla każdego użycia szablonu z~innym typem, generowana jest kopia odpowiednich fragmentów kodu.

Wybrany dla biblioteki SCGL język C~nie posiada żadnego z~wyżej wymienionych mechanizmów.
Aby spełnić postawione wymagania rozważano kilka możliwości projektowych, jedną z~nich było zastosowanie unii z~kilkoma podstawowymi typami zmiennych skalarnych, oraz dodatkowego pola określającego wybrany typ.
Wykorzystanie unii do tego celu, miałoby ograniczyć ilość zużytej pamięci, do największej zmiennej wewnątrz unii.
\begin{lstlisting}[style=code,caption=Koszt krawędzi jako unia]
enum cost_type {INT, DOUBLE, FLOAT};

struct scgl_edge {
   union cost {
       int i;
       double d;
       float f;
   };
   cost_type type;
};
\end{lstlisting}
Rozwiązanie to niestety wymagałoby każdorazowego sprawdzania wartości zmiennej \code{type} przed użyciem zmiennej \code{cost} (ponieważ należy wskazać którą zmienną wybieramy z~unii).
Instrukcja warunkowa \code{switch} (rozrastająca się w~miarę dodawania nowych typów do unii) negatywnie wpłynęłaby na wydajność funkcji wykorzystujących atrybut kosztu.
Alternatywnym rozwiązaniem byłoby stworzenie, dla każdego typu, funkcji posługujących się odpowiednią zmienną z~unii np:
\begin{lstlisting}[style=coden]
void scgl_dijsktra(/*...*/)
void scgl_dijkstra_int(/*...*/)
void scgl_dijkstra_float(/*...*/)
void scgl_dijkstra_double(/*...*/)
\end{lstlisting}
Zmniejszyłoby to narzut wynikający z~każdorazowego sprawdzania typu zmiennej kosztu (sprawdzanie odbywałoby się przez warper \code{scgl\_dijkstra()}, który wywoływałby odpowiednią funkcję).
Niestety rozwiązanie to jednocześnie zwiększyłoby znacznie ilość rozmiar biblioteki, dodatkowo narażając kod na błędy rodzaju copy-paste (wynikające z powielania ciała funkcji poprzez kopiowanie i~wklejanie).
Dodatkową wadą tego rozwiązania, jest fakt, iż unia zajmuje tyle miejsca co jej największa składowa. Gdyby w~jej wnętrzu znalazła się zmienna typu \code{long double} to mimo iż programista wykorzystywał by \code{cost} jako zmienną short, to pole zajmowałoby tyle bajtów ile \code{long double} na danej architekturze.

Z~powodu wyżej wymienionych cech, zdecydowano się zastosować zupełnie inne rozwiązanie.
Postanowiono stworzyć wewnątrz pliku nagłówkowego \emph{scgl\_edge.h} alternatywną nazwę (\code{typedef}), a~następnie zdefiniować wewnątrz struktury krawędzi pole będące realizacją jej kosztu w~następujący sposób:
\begin{lstlisting}[style=code,caption=Koszt krawędzi w~bibliotece SCGL]
typedef cost_type cost_type_t;

struct scgl_edge {
	cost_type_t cost;
};
\end{lstlisting}
Kod ten oczywiście nie ma prawa zadziałać, gdyż symbol \code{cost\_type} dalej pozostaje niezdefiniowany.
Odpowiedzialność za tę czynność przeniesiono do etapu kompilacji biblioteki, a~właściwie etapu translacji.
Kompilator \emph{gcc} poprzez opcję \code{-D} umożliwia definiowanie nazw, traktując je tak jakby w~kodzie pojawił się odpowiednio skonstruowany blok \code{\#define}.
\begin{lstlisting}[style=coden]
gcc -Dname=definition
gcc -Dcost_type=double
gcc -Dcost_type=int
\end{lstlisting}
Kompilując kod z~tym parametrem słowo \code{cost\_type} jest podmieniane na wybrany przez użytkownika typ, co za tym idzie zmienna \code{cost} przybiera wybrany typ.
Statyczny typ zmiennej, dobierany podczas procesu kompilacji nie powoduje dodatkowego narzutu przed jej użyciem (jak to miało miejsce w~przypadku unii), czy na rozmiar biblioteki (szablony języka C++).
Wadą jest tu jednak potrzeba rekompilacji całej biblioteki (wszystkich modułów, które korzystają ze zmiennej), za każdym razem gdy użytkownik zechce zmienić jej typ.
Jest to jednak niedogodność, którą można zaakceptować, zważywszy na możliwości, którą oferuje owe rozwiązanie.

Dodatkowym elementem wynikającym z~wybranego rozwiązania, jest potrzeba dbania o~zależności.
Wybór typu zmiennej powinien dostarczać dodatkowych informacji takich jak minimalna/maksymalna wartość zmiennej, oraz format zmiennej rozumiany przez funkcję \code{printf}.
Aby ułatwić proces budowania biblioteki, oraz zmniejszyć ewentualną możliwość popełnienia błędu przez użytkownika, postanowiono, że doborem wcześniej wymienionych wartości zajmie się plik \emph{Makefile}.
Wewnątrz tego pliku zdefiniowane są reguły budowania całej biblioteki (oraz dodatkowych elementów).
Makefile definiuje zmienną \code{COST\_TYPE}, która może przyjąć wartości odpowiadające określonemu typowi zmiennej \code{cost}.
Na podstawie wyboru użytkownika (zmiennej \code{COST\_TYPE}), Makefile dobierze odpowiednie opcję tak by biblioteka została skompilowana z~obsługą kosztu krawędzi o~wybranym typie.
W~tym celu wewnątrz pliku Makefile stworzono blok decydujący o~następującej strukturze:

\begin{lstlisting}[style=code,caption=Makefile - blok decydujący o zmiennej cost]
ifneq (,$(findstring s,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="short" -Dcost_fmt=\"%hd\" -Dcost_max=SHRT_MAX -Dcost_min=SHRT_MIN
endif
ifneq (,$(findstring us,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned short" -Dcost_fmt=\"%hd\" -Dcost_max=USHRT_MAX -Dcost_min=USHRT_MIN
endif
ifneq (,$(findstring i,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="int" -Dcost_fmt=\"%d\" -Dcost_max=INT_MAX -Dcost_min=INT_MIN
endif
ifneq (,$(findstring ui,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned int" -Dcost_fmt=\"%d\" -Dcost_max=UINT_MAX -Dcost_min=UINT_MIN
endif
ifneq (,$(findstring l,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long" -Dcost_fmt=\"%ld\" -Dcost_max=LONG_MAX -Dcost_min=LONG_MIN
endif
ifneq (,$(findstring ul,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned long" -Dcost_fmt=\"%ld\" -Dcost_max=ULONG_MAX -Dcost_min=ULONG_MIN
endif
ifneq (,$(findstring ll,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long long" -Dcost_fmt=\"%lld\" -Dcost_max=LLONG_MAX -Dcost_min=LLONG_MIN
endif
ifneq (,$(findstring ull,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="unsigned long long" -Dcost_fmt=\"%lld\" -Dcost_max=ULLONG_MAX -Dcost_min=ULLONG_MIN
endif
ifneq (,$(findstring f,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="float" -Dcost_fmt=\"%f\" -Dcost_max=FLT_MAX -Dcost_min=FLT_MIN
endif
ifneq (,$(findstring d,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="double" -Dcost_fmt=\"%f\" -Dcost_max=DBL_MAX -Dcost_min=DBL_MIN
endif
ifneq (,$(findstring ld,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type="long double" -Dcost_fmt=\"%Lf\" -Dcost_max=LDBL_MAX -Dcost_min=LDBL_MIN
endif
\end{lstlisting}

Przedstawiony powyżej wycinek pliku Makefile porównuje zawartość zmiennej \code{COST\_TYPE} z~ustalonymi wcześniej wartościami. Na tej podstawie dobiera odpowiednie zależności, przedstawione w~tabeli \ref{tab:dep}.

Funkcja \code{findstring} wyszukuje wystąpienia pierwszego argumentu wewnątrz drugiego argumentu.
Jeśli wyszukiwanie zakończyło się sukcesem, funkcja zwraca znaleziony ciąg znaków, w~przeciwnym wypadku wynik funkcji jest równy pustemu ciągowi (dlatego sprawdzany jest warunek \code{not equal} z~pustym pierwszym argumentem).

\begin{table}[htb]
\caption{Tabela zależności poszczególnych zmiennych od wartości \code{COST\_TYPE}}
\label{tab:dep}
\begin{tabular}{ | c | c | c | c | c | }
	\hline
	COST\_TYPE  & cost\_type            & cost\_fmt  & cost\_max      & cost\_min      \\
	\hline \hline
	s           & short                 & \%hd       & SHRT\_MAX      & SHRT\_MIN      \\ \hline
	us          & unsigned short        & \%hd       & USHRT\_MAX     & USHRT\_MIN     \\ \hline
	i           & int                   & \%d        & INT\_MAX       & INT\_MIN       \\ \hline
	us          & unsigned int          & \%d        & UINT\_MAX      & UINT\_MIN      \\ \hline
	l           & long                  & \%ld       & LONG\_MAX      & LONG\_MIN      \\ \hline
	ul          & unsigned long         & \%ld       & ULONG\_MAX     & ULONG\_MIN     \\ \hline
	ll          & long long             & \%lld      & LLONG\_MAX     & LLONG\_MIN     \\ \hline
	ull         & unsigned long long    & \%lld      & ULLONG\_MAX    & ULLONG\_MIN    \\ \hline
	f           & float                 & \%f        & FLT\_MAX       & FLT\_MIN       \\ \hline
	d           & double                & \%f        & DBL\_MAX       & DBL\_MIN       \\ \hline
	ld          & long double           & \%Lf       & LDBL\_MAX      & LDBL\_MIN      \\ \hline
\end{tabular}
\end{table}

Posługiwanie się zmienną \code{cost} odbywa się dokładnie tak jak innymi zmiennymi typu skalarnego w~języku C.
Zalecane, aczkolwiek nie wymagane, jest korzystanie z~definicji \code{cost\_max}, \code{cost\_min} oraz \code{cost\_fmt}.
Wartości \code{cost\_max} oraz \code{cost\_min} zdefiniowane są w~plikach nagłówkowych \emph{limits.h} oraz \emph{float.h}. Ich załączenie wymagane jest w~każdym pliku \code{*.c} odwołującym się do zmiennej o~typie \code{cost\_type}.

Użytkownik chcący dodać własny typ może dokonać edycji pliku Makefile.
Powinien przypisać nazwę typu do deklaracji \code{cost\_type}, jej wartość minimalną do \code{cost\_min}, maksymalną do \code{cost\_max}, oraz format dla funkcji \code{printf} do \code{cost\_fmt}.
\begin{lstlisting}[style=coden,caption=Przykład nowego typu kosztu krawędzi]
ifneq (,$(findstring nowy,$(COST_TYPE)))
	override MFLAGS:=-Dcost_type=nowy -Dcost_fmt=\"%format\" -Dcost_max=99 -Dcost_min=-99
endif

\end{lstlisting}
Należy pamiętać o~uciekaniu znaków przy definiowaniu wartości \code{cost\_fmt}.

Dzięki zaproponowanemu rozwiązaniu, biblioteka SCGL zdecydowanie zyskuje na wydajności zarówno czasowej jak i~pamięciowej, nie wprowadzając przy tym zbytniej komplikacji kodu.

\subsection{Algorytm Dijkstry}
ze najszybciej na kopcu kolejka prior, ze kolory, jak to u mnie działa i co można poprawić ze hash lista
\subsection{Testy jednostkowe - DejaGNU}
co to DejaGNU, co to expect i tcl, jak to napisałem czyli wstawka .exp i schemat tests.c (ze switch), co testujemy i po co są testy
\section{Instrukcja użytkownika}
\subsection{Kompilacja}
Makefile jak zbudowany, co buduje, co kasuje, ze dokumentacje zbudujemy wchodząc do doc/latex/make 
\subsection{Interfejs programisty - API}
opisać jak są zbudowane funkcje ze scgl\_moduł\_funkcja, jakie są najważniejsze,ze create/destroy, ze destroy kasuje i ustawia na NULL, jak używać atrybutów przykłady foreach 
\chapter{Porównanie z istniejącymi rozwiązaniami}
TODO:opisać co to, i jaką ma filozofie do grafów - wybór padł na boost bo najpopularniejszy i igraph bo równiez jedna z większych bibliotek
\section{Testy porównawcze}
jak testowałem, na jakich kodach wstawki, czasy wyniki pamięciowe wnioski ze da się szybciej albo czemu coś działa szybciej, szybkość kompilacji
\chapter*{Podsumowanie}
ze można zmniejszyć narzut, ze można usprawnić kopiec, ze można dodać haslistę  ze można dodać algorytmy, 
   ze działa ze dynamiczne ze atrybuty (w igraph to dopiero eksperymentalna opcja), ze szybkie i w miarę małe, 
\addcontentsline{toc}{chapter}{Podsumowanie}
\chapter*{Summary}
\addcontentsline{toc}{chapter}{Summary}
\bibliography{thesis}
\chapter*{Dodatek A. Dokumentacja}
\addcontentsline{toc}{chapter}{Dodatek A. Dokumentacja}
\chapter*{Dodatek B. Oświadczenie}
\addcontentsline{toc}{chapter}{Dodatek B. Oświadczenie}
\chapter*{Dodatek C. Opis zawartości płyty CD}
\addcontentsline{toc}{chapter}{Dodatek C. Opis zawartości płyty CD}

\listoffigures
\listoftables
\lstlistoflistings
%\printindex

\end{document}
